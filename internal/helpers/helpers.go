package helpers

import (
	"encoding/binary"
	"encoding/hex"
	"math/bits"
)

// Uint64IsZero returns 1 iff `u == 0`, 0 otherwise, in constant time.
func Uint64IsZero(u uint64) uint64 {
	isNonzero := Uint64IsNonzero(u)
	return (^isNonzero) & 1
}

// Uint64IsNonzero returns 1 iff `u != 0`, 0 otherwise, in constant time.
func Uint64IsNonzero(u uint64) uint64 {
	_, borrow := bits.Sub64(0, u, 0)
	return borrow
}

// Uint64Equal returns 1 iff `a == b`, 0 otherwise, in constant time.
func Uint64Equal(a, b uint64) uint64 {
	return Uint64IsZero(a ^ b)
}

// FiatLimbsAreEqual returns 1 iff `a == b`, 0 otherwise, in constant time.
// This is correct for the autogenerated fiat routines, as values are
// always in the range `0 <= n < m` (ie: fully reduced).
func FiatLimbsAreEqual(a, b *[4]uint64) uint64 {
	var v uint64

	for i := 0; i < len(a); i++ {
		v |= a[i] ^ b[i]
	}

	return Uint64IsZero(v)
}

// BytesToSaturated interprets src as a 256-bit big-endian integer, and
// returns the 64-bit saturated representation, compatible with the
// autogenerated fiat routines.
func BytesToSaturated(src *[32]byte) [4]uint64 {
	var dst [4]uint64
	dst[3] = binary.BigEndian.Uint64(src[0:8])
	dst[2] = binary.BigEndian.Uint64(src[8:16])
	dst[1] = binary.BigEndian.Uint64(src[16:24])
	dst[0] = binary.BigEndian.Uint64(src[24:32])
	return dst
}

// MustBytesFromHex interprets src as a hex encoded byte-slice, and
// returns the byte representation, or panics.
func MustBytesFromHex(src string) []byte {
	b, err := hex.DecodeString(src)
	if err != nil {
		panic("internal/helpers: invalid hex string: " + err.Error())
	}
	return b
}
