// Copyright (c) 2023 Yawning Angel
//
// SPDX-License-Identifier: BSD-3-Clause

// Code generated by addchain. DO NOT EDIT.

package field

// Sqrt sets `fe = Sqrt(a)`, and returns 1 iff the square root exists.
// In all other cases, `fe = 0`, and 0 is returned.
func (fe *Element) Sqrt(a *Element) (*Element, uint64) {
	tmp := NewElementFrom(a)
	tmp.candidateSqrt(tmp)

	// Check that a square root was actually calculated
	isSqrt := NewElement().Square(tmp).Equal(a)
	fe.ConditionalSelect(&feZero, tmp, isSqrt)

	return fe, isSqrt
}

func (z *Element) candidateSqrt(x *Element) *Element {
	// Square root computation is derived from the addition chain:
	//
	//	_10      = 2*1
	//	_11      = 1 + _10
	//	_1100    = _11 << 2
	//	_1111    = _11 + _1100
	//	_11110   = 2*_1111
	//	_11111   = 1 + _11110
	//	_1111100 = _11111 << 2
	//	_1111111 = _11 + _1111100
	//	x11      = _1111111 << 4 + _1111
	//	x22      = x11 << 11 + x11
	//	x27      = x22 << 5 + _11111
	//	x54      = x27 << 27 + x27
	//	x108     = x54 << 54 + x54
	//	x216     = x108 << 108 + x108
	//	x223     = x216 << 7 + _1111111
	//	return     ((x223 << 23 + x22) << 6 + _11) << 2
	//
	// Operations: 253 squares 13 multiplies
	//
	// Generated by github.com/mmcloughlin/addchain v0.4.0.

	// Allocate Temporaries.
	var (
		t0 = NewElement()
		t1 = NewElement()
		t2 = NewElement()
		t3 = NewElement()
		t4 = NewElement()
	)

	// Step 1: t0 = x^0x2
	t0.Square(x)

	// Step 2: t0 = x^0x3
	t0.Multiply(x, t0)

	// Step 4: t1 = x^0xc
	t1.Pow2k(t0, 2)

	// Step 5: t1 = x^0xf
	t1.Multiply(t0, t1)

	// Step 6: t2 = x^0x1e
	t2.Square(t1)

	// Step 7: t3 = x^0x1f
	t3.Multiply(x, t2)

	// Step 9: t2 = x^0x7c
	t2.Pow2k(t3, 2)

	// Step 10: t2 = x^0x7f
	t2.Multiply(t0, t2)

	// Step 14: t4 = x^0x7f0
	t4.Pow2k(t2, 4)

	// Step 15: t1 = x^0x7ff
	t1.Multiply(t1, t4)

	// Step 26: t4 = x^0x3ff800
	t4.Pow2k(t1, 11)

	// Step 27: t1 = x^0x3fffff
	t1.Multiply(t1, t4)

	// Step 32: t4 = x^0x7ffffe0
	t4.Pow2k(t1, 5)

	// Step 33: t3 = x^0x7ffffff
	t3.Multiply(t3, t4)

	// Step 60: t4 = x^0x3ffffff8000000
	t4.Pow2k(t3, 27)

	// Step 61: t3 = x^0x3fffffffffffff
	t3.Multiply(t3, t4)

	// Step 115: t4 = x^0xfffffffffffffc0000000000000
	t4.Pow2k(t3, 54)

	// Step 116: t3 = x^0xfffffffffffffffffffffffffff
	t3.Multiply(t3, t4)

	// Step 224: t4 = x^0xfffffffffffffffffffffffffff000000000000000000000000000
	t4.Pow2k(t3, 108)

	// Step 225: t3 = x^0xffffffffffffffffffffffffffffffffffffffffffffffffffffff
	t3.Multiply(t3, t4)

	// Step 232: t3 = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffff80
	t3.Pow2k(t3, 7)

	// Step 233: t2 = x^0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff
	t2.Multiply(t2, t3)

	// Step 256: t2 = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffff800000
	t2.Pow2k(t2, 23)

	// Step 257: t1 = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff
	t1.Multiply(t1, t2)

	// Step 263: t1 = x^0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc0
	t1.Pow2k(t1, 6)

	// Step 264: z = x^0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc3
	z.Multiply(t0, t1)

	// Step 266: z = x^0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffbfffff0c
	z.Pow2k(z, 2)

	return z
}
